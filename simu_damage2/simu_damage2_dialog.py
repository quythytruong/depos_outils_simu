# -*- coding: utf-8 -*-
"""
/***************************************************************************
 simu_damage2Dialog
                                 A QGIS plugin
 Simule les endommagements post-ouragans sur une couche de bâtiments
 Generated by Plugin Builder: http://g-sherman.github.io/Qgis-Plugin-Builder/
                             -------------------
        begin                : 2020-09-17
        git sha              : $Format:%H$
        copyright            : (C) 2020 by QT Truong
        email                : quy-thy.truong@ifsttar.fr
 ***************************************************************************/

/***************************************************************************
 *                                                                         *
 *   This program is free software; you can redistribute it and/or modify  *
 *   it under the terms of the GNU General Public License as published by  *
 *   the Free Software Foundation; either version 2 of the License, or     *
 *   (at your option) any later version.                                   *
 *                                                                         *
 ***************************************************************************/
"""

import os

from qgis.PyQt import uic
from qgis.PyQt import QtWidgets, QtCore, QtGui
from qgis.PyQt.QtCore import Qt, QVariant

from qgis.PyQt.QtWidgets import QTableWidgetItem
from .simu_damage2_main_window import Ui_MainWindow

import processing
from qgis.core import QgsCoordinateReferenceSystem, QgsField, QgsProject, QgsFeature, QgsProcessingFeatureSourceDefinition
from qgis.utils import iface


class DamageTableModel(QtCore.QAbstractTableModel):
    '''
        Modèle de données : stocke les proportions d'endommagement sous forme d'un tableau
    '''
    irma_damage = {
        'Peu ou pas endommagé': 0.54,
        'Moyennement endommagé' : 0.22,
        'Fortement endommagé' : 0.17,
        'Détruit' : 0.07
    }
    def __init__(self, data):
        super(DamageTableModel, self).__init__()
        self._data = data
        self.simple_scen_damage = DamageTableModel.irma_damage.copy()
        self.advanced_scen_damage = {}
    '''
    def data(self, index, role):
        if role == Qt.DisplayRole:
            # See below for the nested-list data structure.
            # .row() indexes into the outer list,
            # .column() indexes into the sub-list
            return self._data[index.row()][index.column()]
    '''
    def rowCount(self, index):
        # The length of the outer list.
        return len(self._data)

    def columnCount(self, index):
        # The following takes the first sub-list, and returns
        # the length (only works if all rows are an equal length)
        return len(self._data[0])
    
    def resetDataSimpleScenario(self):
        self.simple_scen_damage = DamageTableModel.irma_damage.copy()
        print(self.simple_scen_damage)
        
    def updateDataSimpleScenario(self, damage_dict):
        ''' Met à jour les pourcentages d'endommagement avec les valeurs entrées par l'utilisateur (scénario simple) '''
        self.simple_scen_damage.update(damage_dict)
        print(self.simple_scen_damage)
        print(DamageTableModel.irma_damage)
    
    def updateDataAdvancedScenario(self, damage_dict):
        ''' Met à jour les pourcentages d'endommagement avec les valeurs entrées par l'utilisateur (scénario avancé) '''
        self.advanced_scen_damage.update(damage_dict)
        print(self.advanced_scen_damage)
    
    def reformatDataAdvancedScenario(self):
        ''' Transformation des données endommagements sous forme de dictionnaire '''
        damage_repartition_per_alea = {}
        for alea, percent_list in self.advanced_scen_damage.items():
            damage_repartition_per_alea[alea] = {
                'Peu ou pas endommagé': percent_list[0],
                'Moyennement endommagé' : percent_list[1],
                'Fortement endommagé' : percent_list[2],
                'Détruit' : percent_list[3]
            }
        return damage_repartition_per_alea
        

class SimuDamageMainWindow(QtWidgets.QMainWindow, Ui_MainWindow):
    def __init__(self, *args, obj=None, **kwargs):
        super(SimuDamageMainWindow, self).__init__(*args, **kwargs)
        self.setupUi(self)
        self.model = DamageTableModel(data = [])    
        
        # Connect signals to slots
        # Push Buttons
        self.pushButton.clicked.connect(self.resetSimpleScenario)
        self.pushButton_3.clicked.connect(self.getAleaUniqueValues)
        self.pushButton_3.clicked.connect(self.startAleaDialog)
        self.pushButton_2.clicked.connect(self.simulateDamage)
        
    def resetSimpleScenario(self):
        # Reset data model
        self.model.resetDataSimpleScenario()
        # Reset data view
        default = []
        for defaultValue in DamageTableModel.irma_damage.values():
            default.append(float("%0.2f" % (defaultValue*100)))
        for i in range(0, len(default)):
            self.tableWidget.setItem(i, 0, QTableWidgetItem(str(default[i])))
            
    def simulateDamage(self):
        print(self.toolBox.currentIndex())
        if self.toolBox.currentIndex() == 0:  # Scénario simple
            print('Simulation Scénario simple')
            if self.checkPercentage():
                self.updateSimpleScenario()
                self.runSimpleScenario()
            else :
                print('La somme des valeurs entrées ne vaut pas 100%')
        elif self.toolBox.currentIndex() == 1:
            self.runAdvancedScenario()
    
    def checkPercentage(self):
        ''' Vérifie que la somme des pourcentages entrés par l'utilisateur vaut 100% '''
        total = 0
        for i in range (0,4):
            percent = self.tableWidget.item(i, 0).text()
            try:
                val = float(percent)
                total += val
            except ValueError:
                print( "The input '" + percent + "' is not a float")
        #print('total = ' + str(total))
        if total == 100.0 :
            return True
        return False
    
    def updateSimpleScenario(self):
        ''' Renvoie les valeurs entrées dans le tableau sous forme de liste '''
        damage_input = {
            'Peu ou pas endommagé': float(self.tableWidget.item(0, 0).text())/100,
            'Moyennement endommagé' : float(self.tableWidget.item(1, 0).text())/100,
            'Fortement endommagé' : float(self.tableWidget.item(2, 0).text())/100,
            'Détruit' : float(self.tableWidget.item(3, 0).text())/100,
        }
        self.model.updateDataSimpleScenario(damage_input)
    
    def runSimpleScenario(self):
        layer = self.mMapLayerComboBox.currentLayer() # Couche des bâtiments
        damage = self.model.simple_scen_damage
        output = self.runDamageScenario(layer, damage)
        QgsProject.instance().addMapLayer(output)
        
    def runAdvancedScenario(self):
        ''' Simulation des endommagements selon différentes répartitions par zones d'aléas '''
        
        buildings = self.mMapLayerComboBox.currentLayer() # Couche des bâtiments
        aleaZone = self.mMapLayerComboBox_2.currentLayer() # Couche des aléas
        damageRepartition = self.model.reformatDataAdvancedScenario()
        
        # Duplique la couche de bâtiments la couche d'entrée : sélectionne toutes les entités et les exporte dans une nouvelle couche
        buildings.selectAll() 
        buildings_copy = processing.run("native:saveselectedfeatures", {'INPUT': buildings, 'OUTPUT': 'memory:'})['OUTPUT']
        buildings_copy.setCrs(QgsCoordinateReferenceSystem(buildings.crs()))
        self.unselectAll() # Désélectionne toutes les entités
        
        # Interaction avec la couche des aléas
        aleaAttr = self.mFieldComboBox.currentText()
        #aleaAttrIndex = provider.fieldNameIndex(aleaAttr) # Index du champ Aléa
        damagedLayers = [] # Liste des couches de bâtiments endommagés à fusionner        
        for zone in aleaZone.getFeatures():
            aleaZone.select([zone.id()]) # Sélectionne la zone
            damage = damageRepartition[zone[aleaAttr]]
            # Extrait les bâtiments qui intersectent la zone
            param_extract = {
                'INPUT' : buildings_copy,
                'PREDICATE': 0,
                'INTERSECT': QgsProcessingFeatureSourceDefinition(aleaZone.id(), True),
                'OUTPUT': 'memory:'
            }
            bati_extracted = processing.run("native:extractbylocation", param_extract)['OUTPUT']
            aleaZone.removeSelection() # Efface la sélection
            #QgsProject.instance().addMapLayer(bati_extracted)            
            output = self.runDamageScenario(bati_extracted, damage)
            damagedLayers.append(output)
            output.setName('Aléa ' + str(zone[aleaAttr]))
            #QgsProject.instance().addMapLayer(output)
            
        # Cas des bâtiments qui sont disjoints de toute zone d'alés
        param_extract = {
                'INPUT' : buildings_copy,
                'PREDICATE': 2,
                'INTERSECT': aleaZone,
                'OUTPUT': 'memory:'
            }
        bati_disjoint = processing.run("native:extractbylocation", param_extract)['OUTPUT']
        # Par défaut : les bâtiments sont à 100% peu ou pas endommagés
        minDamage = {
            'Peu ou pas endommagé': 1,
            'Moyennement endommagé' : 0,
            'Fortement endommagé' : 0,
            'Détruit' : 0
        }
        output = self.runDamageScenario(bati_disjoint, minDamage)
        #output = self.runDamageScenario(bati_disjoint, DamageTableModel.irma_damage) # Prend les valeurs par défaut (Irma)
        damagedLayers.append(output)
        
        # Fusion des couches générées
        param_merge = {'LAYERS' : damagedLayers, 'OUTPUT' : 'memory:'}
        fusion = processing.run('native:mergevectorlayers', param_merge)['OUTPUT']
        count=fusion.fields().count() # count of layer fields
        # remove a single field with an index
        fusion.dataProvider().deleteAttributes([count-1, count-2])
        fusion.updateFields()
        fusion.setName('Endommagements par zone d\'aléa')
        QgsProject.instance().addMapLayer(fusion)
        
    def runDamageScenario(self, buildingLayer, damageRepartition):
        ''' Endommagement des bâtiments selon des niveaux de dommages fixés '''
        #  Cloner la couche d'entrée : sélectionne toutes les entités et les exporte dans une nouvelle couche
        buildingLayer.selectAll() 
        duplicateLayer = processing.run("native:saveselectedfeatures", {'INPUT': buildingLayer, 'OUTPUT': 'memory:'})['OUTPUT']
        duplicateLayer.setCrs(QgsCoordinateReferenceSystem(buildingLayer.crs()))
        self.unselectAll() # Désélectionne toutes les entités
            
        duplicateLayer.startEditing() # Mode édition
        duplicateLayer.addAttribute(QgsField('endommagement', QVariant.String)) # Création champ endommagement
        duplicateLayer.updateFields()
            
        n_destroyed = round(damageRepartition['Détruit']*buildingLayer.featureCount())
        duplicateLayer = self.selectRandomFeatures(duplicateLayer, n_destroyed)
        destroyed_layer, duplicateLayer = self.extractSelectedFeatures(duplicateLayer, 'Détruit')
            
        n_high_damaged = round(damageRepartition['Fortement endommagé']*buildingLayer.featureCount())
        duplicateLayer = self.selectRandomFeatures(duplicateLayer, n_high_damaged)
        highdamaged_layer, duplicateLayer = self.extractSelectedFeatures(duplicateLayer, 'Fortement endommagé')
            
        n_damaged = round(damageRepartition['Moyennement endommagé']*buildingLayer.featureCount())
        duplicateLayer = self.selectRandomFeatures(duplicateLayer, n_damaged)
        damaged_layer, duplicateLayer = self.extractSelectedFeatures(duplicateLayer, 'Moyennement endommagé')
        
        # Met à jour les données restantes = peu ou pas endommagés
        duplicateLayer.startEditing()
        duplicateLayer.selectAll()
        features = duplicateLayer.selectedFeatures()
        dfeats = []
        for f in features:
            f['endommagement'] = 'Peu ou pas endommagé'
            duplicateLayer.updateFeature(f)
            dfeats.append(f.id())
        duplicateLayer.commitChanges()
        self.unselectAll()
  
        # Ajoute une couche fusionnée
        param_merge = {'LAYERS' : [destroyed_layer, highdamaged_layer, damaged_layer, duplicateLayer], 'OUTPUT' : 'memory:'}
        fusion = processing.run('native:mergevectorlayers', param_merge)['OUTPUT']
        count=fusion.fields().count() # count of layer fields
        # remove a single field with an index
        fusion.dataProvider().deleteAttributes([count-1, count-2])
        fusion.updateFields()
        fusion.setName('Endommagements (fusion)')
        return fusion

    def unselectAll(self):
        """ Désélectionne toutes les entités """
        for a in iface.attributesToolBar().actions():
                if a.objectName() == 'mActionDeselectAll':
                    a.trigger()
                    break
                    
                    
    def selectRandomFeatures(self, layer, n):
        """ Sélectionne aléatoirement un nombre d'éléments """
        param_random_destroyed = {'INPUT' : layer, 'METHOD':0, 'NUMBER': n}
        processing.run("qgis:randomselection",param_random_destroyed) # Sélectionne les détruits
        return layer
        
    def extractSelectedFeatures(self, layer, damage_value):
        """ Exporte les éléments sélectionnés d'une couche dans une nouvelle couche et les supprime de la première couche """
        # Itération sur les éléments sélectionnés
        layer.startEditing()
        features = layer.selectedFeatures()
        dfeats = []
        for f in features:
            f['endommagement'] = damage_value
            layer.updateFeature(f)
            dfeats.append(f.id())
        layer.commitChanges()
        damaged_layer = processing.run("native:saveselectedfeatures", {'INPUT': layer, 'OUTPUT': 'memory:'})['OUTPUT']
        damaged_layer.setCrs(QgsCoordinateReferenceSystem(layer.crs()))
        #damaged_layer.setName(damage_value)
        #QgsProject.instance().addMapLayer(damaged_layer)
            
        # loop over the features and delete
        layer.dataProvider().deleteFeatures(dfeats)
        print(layer.featureCount())            
        self.unselectAll()
        return damaged_layer, layer
    
    def startAleaDialog(self):
        data = self.initAdvancedSimu()
        dialog = AleaDamagePercentDialog(data)
        # Run the dialog event loop
        result = dialog.exec_()
        # See if OK was pressed
        if result:
            input_simu_advanced = dialog.getDataInput()
            self.model.updateDataAdvancedScenario(input_simu_advanced)
    
    def initAdvancedSimu(self):
        if len(self.model.advanced_scen_damage) == 0:
            aleas = self.getAleaUniqueValues()
            init_damage = {}
            for level in aleas :
                init_damage[level] = [0.0,0.0,0.0,0.0]
            self.model.updateDataAdvancedScenario(init_damage)
        return self.model.advanced_scen_damage
            
    def getAleaUniqueValues(self):
        layer = self.mMapLayerComboBox_2.currentLayer()
        aleaAttr = self.mFieldComboBox.currentText()
        uniquevalues_param = {'INPUT': layer, 'FIELDS': aleaAttr}
        result = processing.run('qgis:listuniquevalues', uniquevalues_param)
        zones_alea = result['UNIQUE_VALUES'].split(';')
        #print(zones_alea)
        return zones_alea
        
    
FORM_CLASS_ALEA, _ = uic.loadUiType(os.path.join(
    os.path.dirname(__file__), 'alea_pourcentages_dialog.ui'))
class AleaDamagePercentDialog(QtWidgets.QDialog, FORM_CLASS_ALEA):
    def __init__(self, data, parent=None):
        """Constructor."""
        super(AleaDamagePercentDialog, self).__init__(parent)
        self.setupUi(self)
        self.setData(data)
        #self.tableWidget.setColumnCount(len(columns))
        #self.tableWidget.setHorizontalHeaderLabels(columns)
        #self.tableWidget.cellChanged.connect(self.onCellChanged) # TODO : gérer la répartition des endommagements pour que le total vaille 100%
   
    def setData(self, data):
        ''' Remplit le tableau avec les données du modèle '''     
        self.tableWidget.setColumnCount(len(data))
        horHeaders = []
        for n, aleaLevel in enumerate(sorted(data.keys())):
            horHeaders.append(aleaLevel)
            for m, percent in enumerate(data[aleaLevel]):
                newitem = QTableWidgetItem(str(percent*100))
                self.tableWidget.setItem(m, n, newitem)
            self.countTotalRow(n)
        self.tableWidget.setHorizontalHeaderLabels(horHeaders)
        
    def countTotalRow(self, column):
        ''' Met à jour la ligne des totaux '''
        total = 0
        for i in range(0,4):
            try :
                total += self.getCellValue(i, column)
            except ValueError:
                error_msg = QTableWidgetItem("ERREUR")
                self.tableWidget.setItem(4, column, error_msg)
        newitem = QTableWidgetItem(str(total))
        self.tableWidget.setItem(4, column, newitem)
        
    def getCellValue(self, row, column):
        try :
            value = float(self.tableWidget.item(row, column).text())
        except ValueError:
            print("ERREUR")
        return value
    
    def onCellChanged(self):
        col = self.tableWidget.currentColumn()
        self.countTotalRow(col)
        
    def getDataInput(self):
        ''' Renvoie les données entrées pour être stockées dans le modèle '''
        data = {}
        num_rows, num_cols = self.tableWidget.rowCount()-1, self.tableWidget.columnCount()
        for i in range(num_cols):
            zone_alea = self.tableWidget.horizontalHeaderItem(i).text()
            percent_damage = []
            for j in range(num_rows):
                percent_damage.append(self.getCellValue(j,i)/100)
            data[zone_alea] = percent_damage
        #print(data)
        return data
        